import torch as th
import torch.nn as nn
import numpy as np
import random

def gci0_loss(objects, exponential_net,  embed_objects, class_reg, neg = False):

    antecedents = embed_objects(objects[:, 0])
    consequents = embed_objects(objects[:, 1])
            
    loss = exponential_net(antecedents, consequents, get_indices = True)
    reg_loss = class_reg(antecedents) + class_reg(consequents)
    assert loss.shape == reg_loss.shape, f"{loss.shape}, {reg_loss.shape}"
    return loss + reg_loss, indices, nb_ents

def gci2_loss(objects, exp_net, slicing_net, embed_objects, embed_rels, class_reg,  neg = False, num_objects = None, device = "cpu", indices = None, idx_for_negs = None):
    
    antecedents = embed_objects(objects[:, 0])
    relations = embed_rels(objects[:, 1])
    consequents = embed_objects(objects[:, 2])

    if neg:
        negs = th.tensor(np.random.choice(idx_for_negs, size = len(objects))).to(device)
        #negs = th.tensor(np.random.choice(num_objects, size = len(objects))).to(device)
        consequents  = embed_objects(negs)

    sliced_prod, prod_loss, nb_ents_slicing = slicing_net(relations, consequents, antecedents)

    if neg:
        exp_loss = exp_net(antecedents, sliced_prod, neg=neg, indices = indices)
    else:
        exp_loss, indices = exp_net(antecedents, sliced_prod, neg=neg, get_indices = True)
        
    reg_loss = class_reg(antecedents) + class_reg(consequents) + class_reg(sliced_prod)
    return (exp_loss + prod_loss) + reg_loss, indices, nb_ents_slicing + 1

def gci3_loss(objects, exp_net, slicing_net, embed_objects, embed_rels, class_reg, neg = False, num_objects = None, device = "cpu", indices = None):

    relations = embed_rels(objects[:, 0])
    antecedents = embed_objects(objects[:, 1])
    consequents = embed_objects(objects[:, 2])

    if neg:
        negs = th.tensor(np.random.choice(num_objects, size = len(objects))).to(device)
        embed_negs = embed_objects(negs)
        consequents = embed_negs

    sliced_prod, prod_loss, nb_ents_slicing = slicing_net(relations, antecedents, consequents)

    if neg:
        exp_loss = exp_net(sliced_prod, consequents,neg=neg, indices = indices)
    else:
        exp_loss, indices = exp_net(sliced_prod, consequents,neg=neg, get_indices = True)

    reg_loss = class_reg(antecedents) + class_reg(consequents) + class_reg(sliced_prod)
    return (prod_loss + exp_loss) + reg_loss, indices, nb_ents_slicing + 1


    
def gci2_loss(objects, exp_net, prod_net, embed_objects, class_reg, neg = False, num_objects = None, device = "cpu", indices = None):

    antecedents_left = embed_objects(objects[:, 0])
    antecedents_right = embed_objects(objects[:, 1])
    consequents = embed_objects(objects[:, 2])

    prod, prod_loss, nb_ents_prod = prod_net(antecedents_left, antecedents_right)
    if neg:
        negs = th.tensor(np.random.choice(num_objects, size = len(objects))).to(device)
        embed_negs = embed_objects(negs)
        consequents_neg = embed_negs
        exp_loss_neg = exp_net(prod, consequents_neg, neg=neg, indices = indices)
        neg_loss_1 = prod_loss + exp_loss_neg
        
        # negs = th.tensor(np.random.choice(num_objects, size = len(objects))).to(device)
        # embed_negs = embed_objects(negs)
        # prod_neg_1, prod_loss_1 = prod_net(antecedents_left, embed_negs)
        # exp_loss = exp_net(prod_neg_1, consequents)
        # neg_loss_2 = prod_loss_1 + exp_loss

        # negs = th.tensor(np.random.choice(num_objects, size = len(objects))).to(device)
        # embed_negs = embed_objects(negs)
        # prod_neg_2, prod_loss_2 = prod_net(embed_negs, antecedents_right)
        # exp_loss = exp_net(prod_neg_2, consequents)
        # neg_loss_3 = prod_loss_2 + exp_loss

        reg_loss = class_reg(antecedents_left) + class_reg(consequents_right) + class_reg(consequents_neg)
        return neg_loss_1+reg_loss, nb_ents_prod + 1
        #return (neg_loss_2 + neg_loss_3)/2
        #return (neg_loss_1 + neg_loss_2 + neg_loss_3)/3
        
    else:
        exp_loss, indices = exp_net(prod, consequents,neg=neg, get_indices = True)
        reg_loss = class_reg(antecedents_left) + class_reg(consequents_right) + class_reg(consequents)
        return prod_loss + exp_loss + neg_loss, indices, nb_ents_prod + 1
